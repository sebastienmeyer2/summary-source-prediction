<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>src.preprocessing.features.manual_regex API documentation</title>
<meta name="description" content="Compute features based on regex expressions." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.preprocessing.features.manual_regex</code></h1>
</header>
<section id="section-intro">
<p>Compute features based on regex expressions.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Compute features based on regex expressions.&#34;&#34;&#34;


from typing import List, Optional

from pandas import DataFrame


def apply_regex_rule(rule: str, df: DataFrame, expr: str, feat_name: str, summary: bool = True):
    &#34;&#34;&#34;Apply a regex expression and perform an operation on the results of the query.

    Parameters
    ----------
    rule : str
        Rule to use after applying the regex **expr**, either &#34;count&#34; for the number of found
        instances, &#34;set&#34; to transform the result into a set or &#34;avg&#34; to compute the average length
        of found instances.

    df : DataFrame
        A dataframe containing the corresponding column, either &#34;summary&#34; if **summary** is True,
        or &#34;document&#34; if **summary** is False.

    expr : str
        The regex expression to apply.

    feat_name : str
        Name of the new feature to append to the dataframe.

    summary : bool, default=True
        If True, will apply the regex **expr** on the &#34;summary&#34; column of the dataframe, otherwise
        on the &#34;document&#34; column.

    Raises
    ------
    ValueError
        If the corresponding column &#34;summary&#34; or &#34;document&#34; is not present in **df**, depending on
        the value of **summary**. If the **rule** is not supported.
    &#34;&#34;&#34;
    if feat_name not in df.columns:

        # Choose the column to which the rule must be applied
        col = &#34;summary&#34; if summary else &#34;document&#34;

        if col not in df.columns:

            err_msg = f&#34;Column {col} not present in the dataframe.&#34;
            raise ValueError(err_msg)

        # Apply the rule and put the result in a new column
        if rule == &#34;count&#34;:

            df[feat_name] = df[col].str.findall(expr).str.len().astype(float)

        elif rule == &#34;set&#34;:

            df[feat_name] = df[col].str.findall(expr).apply(set)

        elif rule == &#34;avg&#34;:

            def avg(arr_of_str):
                n = len(arr_of_str)
                mean = 0.
                if n == 0:
                    return mean
                for x in arr_of_str:
                    mean += len(x)
                mean /= n
                return mean

            col = &#34;summary&#34; if summary else &#34;document&#34;
            df[feat_name] = df[col].str.findall(expr).apply(avg)

        else:

            err_msg = f&#34;Unknown regex rule {rule}.&#34;
            raise ValueError(err_msg)


def regex_name_to_expr(feat_regex_name: str) -&gt; str:
    &#34;&#34;&#34;Convert a feature name to its corresponding regex expression.

    Parameters
    ----------
    feat_regex_name : str
        Name of the feature to compute.

    Returns
    -------
    expr : str
        Corresponding regex expression.

    Raises
    ------
    ValueError
        If the **feat_regex_name** is not supported.
    &#34;&#34;&#34;
    # Features associated to length
    if feat_regex_name == &#34;char&#34;:

        # This expression captures all characters, even commas, periods, dashes, numbers and white
        # spaces.
        expr = r&#34;.&#34;

    elif feat_regex_name == &#34;word&#34;:

        # This expression captures all words, which are separated either by commas, periods or
        # dashs. Please note that this expression might capture numbers aswell.
        expr = r&#34;\b\w+\b&#34;

    elif feat_regex_name == &#34;sent&#34;:

        # This expression captures all sentences
        expr = r&#34;([A-Z][^\.!?]*[\.!?])&#34;

    # Features associated to uppercase, lowercase and special characters
    elif feat_regex_name == &#34;upper_char&#34;:

        # This expression captures all upper characters
        expr = r&#34;[A-Z]&#34;

    elif feat_regex_name == &#34;upper_word&#34;:

        # This expression captures all words starting with a capital letter
        expr = r&#34;\b[A-Z]\w+&#34;

    elif feat_regex_name == &#34;numeric&#34;:

        # This expression captures all numbers which might be separated either by commas, periods
        # or dashs
        expr = r&#34;[0-9]&#34;

    elif feat_regex_name == &#34;dash&#34;:

        # This expression captures all dashes
        expr = r&#34;[-]&#34;

    # Features associated to groups
    elif feat_regex_name == &#34;group&#34;:

        # This expression captures all groups of consecutive words which start with a capital
        # letter
        expr = r&#34;([A-Z][\w-]*(?:\s+[A-Z][\w-]*)+)&#34;

    # Features associated to beginning and end of string
    elif feat_regex_name == &#34;is_first_upper&#34;:

        # This expression captures the first character iff it is uppercase
        expr = r&#34;^[A-Z]&#34;

    elif feat_regex_name == &#34;is_last_ponct&#34;:

        # This expression captures the last character iff it is a ponctuation
        expr = r&#34;[?.!,:;&#39;]$&#34;

    elif feat_regex_name == &#34;space_before_ponct&#34;:

        # This expression captures all white spaces which are before ponctuation
        expr = r&#34;[ ][?.!,:;&#39;]&#34;

    elif &#34;word_&#34; in feat_regex_name:

        n = feat_regex_name.split(&#34;_&#34;)[-1]

        if n not in [f&#34;{i}&#34; for i in range(1, 11)]:

            err_msg = f&#34;Unsupported number of chars in word {n}.&#34;
            raise ValueError(err_msg)

        # This expression captures all words of specific length which are separated either by
        # commas, periods or dashs. Please note that it might capture numbers aswell.
        expr = fr&#34;\b\w{{{n}}}\b&#34;

    else:

        err_msg = f&#34;Unsupported regex feature {feat_regex_name}.&#34;
        raise ValueError(err_msg)

    return expr


def create_regex_feat(
    train_df: DataFrame, test_df: Optional[DataFrame] = None,
    regex_feat: Optional[List[str]] = None
):
    &#34;&#34;&#34;Auxiliary function to create regex features.

    Parameters
    ----------
    train_df : DataFrame
        Training dataframe containing &#34;summary&#34; and &#34;document&#34; columns.

    test_df : optional DataFrame, default=None
        Test dataframe containing &#34;summary&#34; and &#34;document&#34; columns.

    regex_feat : optional list of str, default=None
        List of all regex features to compute. The name of a regex feature should be of the form
        &#34;A_B&#34;. A is the name of the regex expression, for example &#34;upper_word&#34;. B is the type of
        feature we want, it can be &#34;count&#34; for the number of instances, &#34;avg&#34; for the average
        length of instances, &#34;overlap&#34; for the number of instances both found in the summary and
        the original document or &#34;ratio&#34; for the ratio between the number of instances found in the
        summary and the number of instances found in the document.

    Raises
    ------
    ValueError
        If one of the features is not supported.
    &#34;&#34;&#34;
    if regex_feat is None or len(regex_feat) == 0:
        return

    print(&#34;\nComputing regex features...&#34;)

    init_feat = set(train_df.columns)
    new_feat = set()

    dfs = [train_df]
    if test_df is not None:
        dfs.append(test_df)

    for feat_name in regex_feat:

        for df in dfs:

            feat_split = feat_name.split(&#34;_&#34;)
            feat_type = feat_split[-1]
            feat_regex_name = &#34;_&#34;.join(feat_split[:-1])
            feat_regex_expr = regex_name_to_expr(feat_regex_name)

            if feat_type == &#34;count&#34;:

                apply_regex_rule(&#34;count&#34;, df, feat_regex_expr, feat_name)

            elif feat_type == &#34;avg&#34;:

                apply_regex_rule(&#34;avg&#34;, df, feat_regex_expr, feat_name)

            elif feat_type == &#34;overlap&#34;:

                s_feat_name = feat_regex_name + &#34;_set&#34;
                d_feat_name = &#34;d_&#34; + feat_regex_name + &#34;_set&#34;

                apply_regex_rule(&#34;set&#34;, df, feat_regex_expr, s_feat_name)
                apply_regex_rule(&#34;set&#34;, df, feat_regex_expr, d_feat_name, summary=False)
                df[feat_name] = [
                    len(x[0] &amp; x[1]) for x in df[[s_feat_name, d_feat_name]].values
                ]

            elif feat_type == &#34;ratio&#34;:

                s_feat_name = feat_regex_name + &#34;_count&#34;
                d_feat_name = &#34;d_&#34; + feat_regex_name + &#34;_count&#34;

                apply_regex_rule(&#34;count&#34;, df, feat_regex_expr, s_feat_name)
                apply_regex_rule(&#34;count&#34;, df, feat_regex_expr, d_feat_name, summary=False)
                df[feat_name] = df[s_feat_name] / df[d_feat_name]

            else:

                err_msg = f&#34;From regex feature {feat_name}, unsupported feature type {feat_type}.&#34;
                raise ValueError(err_msg)

        new_feat.add(feat_name)

    # Drop intermediary features
    inter_feat = set(train_df.columns).difference(init_feat.union(new_feat))

    train_df.drop(columns=inter_feat, inplace=True)
    if test_df is not None:
        test_df.drop(columns=inter_feat, inplace=True)

    print(f&#34;Number of regex features: {len(new_feat)}.&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.preprocessing.features.manual_regex.apply_regex_rule"><code class="name flex">
<span>def <span class="ident">apply_regex_rule</span></span>(<span>rule: str, df: pandas.core.frame.DataFrame, expr: str, feat_name: str, summary: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a regex expression and perform an operation on the results of the query.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rule</code></strong> :&ensp;<code>str</code></dt>
<dd>Rule to use after applying the regex <strong>expr</strong>, either "count" for the number of found
instances, "set" to transform the result into a set or "avg" to compute the average length
of found instances.</dd>
<dt><strong><code>df</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>A dataframe containing the corresponding column, either "summary" if <strong>summary</strong> is True,
or "document" if <strong>summary</strong> is False.</dd>
<dt><strong><code>expr</code></strong> :&ensp;<code>str</code></dt>
<dd>The regex expression to apply.</dd>
<dt><strong><code>feat_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the new feature to append to the dataframe.</dd>
<dt><strong><code>summary</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>If True, will apply the regex <strong>expr</strong> on the "summary" column of the dataframe, otherwise
on the "document" column.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the corresponding column "summary" or "document" is not present in <strong>df</strong>, depending on
the value of <strong>summary</strong>. If the <strong>rule</strong> is not supported.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_regex_rule(rule: str, df: DataFrame, expr: str, feat_name: str, summary: bool = True):
    &#34;&#34;&#34;Apply a regex expression and perform an operation on the results of the query.

    Parameters
    ----------
    rule : str
        Rule to use after applying the regex **expr**, either &#34;count&#34; for the number of found
        instances, &#34;set&#34; to transform the result into a set or &#34;avg&#34; to compute the average length
        of found instances.

    df : DataFrame
        A dataframe containing the corresponding column, either &#34;summary&#34; if **summary** is True,
        or &#34;document&#34; if **summary** is False.

    expr : str
        The regex expression to apply.

    feat_name : str
        Name of the new feature to append to the dataframe.

    summary : bool, default=True
        If True, will apply the regex **expr** on the &#34;summary&#34; column of the dataframe, otherwise
        on the &#34;document&#34; column.

    Raises
    ------
    ValueError
        If the corresponding column &#34;summary&#34; or &#34;document&#34; is not present in **df**, depending on
        the value of **summary**. If the **rule** is not supported.
    &#34;&#34;&#34;
    if feat_name not in df.columns:

        # Choose the column to which the rule must be applied
        col = &#34;summary&#34; if summary else &#34;document&#34;

        if col not in df.columns:

            err_msg = f&#34;Column {col} not present in the dataframe.&#34;
            raise ValueError(err_msg)

        # Apply the rule and put the result in a new column
        if rule == &#34;count&#34;:

            df[feat_name] = df[col].str.findall(expr).str.len().astype(float)

        elif rule == &#34;set&#34;:

            df[feat_name] = df[col].str.findall(expr).apply(set)

        elif rule == &#34;avg&#34;:

            def avg(arr_of_str):
                n = len(arr_of_str)
                mean = 0.
                if n == 0:
                    return mean
                for x in arr_of_str:
                    mean += len(x)
                mean /= n
                return mean

            col = &#34;summary&#34; if summary else &#34;document&#34;
            df[feat_name] = df[col].str.findall(expr).apply(avg)

        else:

            err_msg = f&#34;Unknown regex rule {rule}.&#34;
            raise ValueError(err_msg)</code></pre>
</details>
</dd>
<dt id="src.preprocessing.features.manual_regex.create_regex_feat"><code class="name flex">
<span>def <span class="ident">create_regex_feat</span></span>(<span>train_df: pandas.core.frame.DataFrame, test_df: Optional[pandas.core.frame.DataFrame] = None, regex_feat: Optional[List[str]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Auxiliary function to create regex features.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>train_df</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>Training dataframe containing "summary" and "document" columns.</dd>
<dt><strong><code>test_df</code></strong> :&ensp;<code>optional DataFrame</code>, default=<code>None</code></dt>
<dd>Test dataframe containing "summary" and "document" columns.</dd>
<dt><strong><code>regex_feat</code></strong> :&ensp;<code>optional list</code> of <code>str</code>, default=<code>None</code></dt>
<dd>List of all regex features to compute. The name of a regex feature should be of the form
"A_B". A is the name of the regex expression, for example "upper_word". B is the type of
feature we want, it can be "count" for the number of instances, "avg" for the average
length of instances, "overlap" for the number of instances both found in the summary and
the original document or "ratio" for the ratio between the number of instances found in the
summary and the number of instances found in the document.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If one of the features is not supported.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_regex_feat(
    train_df: DataFrame, test_df: Optional[DataFrame] = None,
    regex_feat: Optional[List[str]] = None
):
    &#34;&#34;&#34;Auxiliary function to create regex features.

    Parameters
    ----------
    train_df : DataFrame
        Training dataframe containing &#34;summary&#34; and &#34;document&#34; columns.

    test_df : optional DataFrame, default=None
        Test dataframe containing &#34;summary&#34; and &#34;document&#34; columns.

    regex_feat : optional list of str, default=None
        List of all regex features to compute. The name of a regex feature should be of the form
        &#34;A_B&#34;. A is the name of the regex expression, for example &#34;upper_word&#34;. B is the type of
        feature we want, it can be &#34;count&#34; for the number of instances, &#34;avg&#34; for the average
        length of instances, &#34;overlap&#34; for the number of instances both found in the summary and
        the original document or &#34;ratio&#34; for the ratio between the number of instances found in the
        summary and the number of instances found in the document.

    Raises
    ------
    ValueError
        If one of the features is not supported.
    &#34;&#34;&#34;
    if regex_feat is None or len(regex_feat) == 0:
        return

    print(&#34;\nComputing regex features...&#34;)

    init_feat = set(train_df.columns)
    new_feat = set()

    dfs = [train_df]
    if test_df is not None:
        dfs.append(test_df)

    for feat_name in regex_feat:

        for df in dfs:

            feat_split = feat_name.split(&#34;_&#34;)
            feat_type = feat_split[-1]
            feat_regex_name = &#34;_&#34;.join(feat_split[:-1])
            feat_regex_expr = regex_name_to_expr(feat_regex_name)

            if feat_type == &#34;count&#34;:

                apply_regex_rule(&#34;count&#34;, df, feat_regex_expr, feat_name)

            elif feat_type == &#34;avg&#34;:

                apply_regex_rule(&#34;avg&#34;, df, feat_regex_expr, feat_name)

            elif feat_type == &#34;overlap&#34;:

                s_feat_name = feat_regex_name + &#34;_set&#34;
                d_feat_name = &#34;d_&#34; + feat_regex_name + &#34;_set&#34;

                apply_regex_rule(&#34;set&#34;, df, feat_regex_expr, s_feat_name)
                apply_regex_rule(&#34;set&#34;, df, feat_regex_expr, d_feat_name, summary=False)
                df[feat_name] = [
                    len(x[0] &amp; x[1]) for x in df[[s_feat_name, d_feat_name]].values
                ]

            elif feat_type == &#34;ratio&#34;:

                s_feat_name = feat_regex_name + &#34;_count&#34;
                d_feat_name = &#34;d_&#34; + feat_regex_name + &#34;_count&#34;

                apply_regex_rule(&#34;count&#34;, df, feat_regex_expr, s_feat_name)
                apply_regex_rule(&#34;count&#34;, df, feat_regex_expr, d_feat_name, summary=False)
                df[feat_name] = df[s_feat_name] / df[d_feat_name]

            else:

                err_msg = f&#34;From regex feature {feat_name}, unsupported feature type {feat_type}.&#34;
                raise ValueError(err_msg)

        new_feat.add(feat_name)

    # Drop intermediary features
    inter_feat = set(train_df.columns).difference(init_feat.union(new_feat))

    train_df.drop(columns=inter_feat, inplace=True)
    if test_df is not None:
        test_df.drop(columns=inter_feat, inplace=True)

    print(f&#34;Number of regex features: {len(new_feat)}.&#34;)</code></pre>
</details>
</dd>
<dt id="src.preprocessing.features.manual_regex.regex_name_to_expr"><code class="name flex">
<span>def <span class="ident">regex_name_to_expr</span></span>(<span>feat_regex_name: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a feature name to its corresponding regex expression.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>feat_regex_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the feature to compute.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>expr</code></strong> :&ensp;<code>str</code></dt>
<dd>Corresponding regex expression.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the <strong>feat_regex_name</strong> is not supported.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regex_name_to_expr(feat_regex_name: str) -&gt; str:
    &#34;&#34;&#34;Convert a feature name to its corresponding regex expression.

    Parameters
    ----------
    feat_regex_name : str
        Name of the feature to compute.

    Returns
    -------
    expr : str
        Corresponding regex expression.

    Raises
    ------
    ValueError
        If the **feat_regex_name** is not supported.
    &#34;&#34;&#34;
    # Features associated to length
    if feat_regex_name == &#34;char&#34;:

        # This expression captures all characters, even commas, periods, dashes, numbers and white
        # spaces.
        expr = r&#34;.&#34;

    elif feat_regex_name == &#34;word&#34;:

        # This expression captures all words, which are separated either by commas, periods or
        # dashs. Please note that this expression might capture numbers aswell.
        expr = r&#34;\b\w+\b&#34;

    elif feat_regex_name == &#34;sent&#34;:

        # This expression captures all sentences
        expr = r&#34;([A-Z][^\.!?]*[\.!?])&#34;

    # Features associated to uppercase, lowercase and special characters
    elif feat_regex_name == &#34;upper_char&#34;:

        # This expression captures all upper characters
        expr = r&#34;[A-Z]&#34;

    elif feat_regex_name == &#34;upper_word&#34;:

        # This expression captures all words starting with a capital letter
        expr = r&#34;\b[A-Z]\w+&#34;

    elif feat_regex_name == &#34;numeric&#34;:

        # This expression captures all numbers which might be separated either by commas, periods
        # or dashs
        expr = r&#34;[0-9]&#34;

    elif feat_regex_name == &#34;dash&#34;:

        # This expression captures all dashes
        expr = r&#34;[-]&#34;

    # Features associated to groups
    elif feat_regex_name == &#34;group&#34;:

        # This expression captures all groups of consecutive words which start with a capital
        # letter
        expr = r&#34;([A-Z][\w-]*(?:\s+[A-Z][\w-]*)+)&#34;

    # Features associated to beginning and end of string
    elif feat_regex_name == &#34;is_first_upper&#34;:

        # This expression captures the first character iff it is uppercase
        expr = r&#34;^[A-Z]&#34;

    elif feat_regex_name == &#34;is_last_ponct&#34;:

        # This expression captures the last character iff it is a ponctuation
        expr = r&#34;[?.!,:;&#39;]$&#34;

    elif feat_regex_name == &#34;space_before_ponct&#34;:

        # This expression captures all white spaces which are before ponctuation
        expr = r&#34;[ ][?.!,:;&#39;]&#34;

    elif &#34;word_&#34; in feat_regex_name:

        n = feat_regex_name.split(&#34;_&#34;)[-1]

        if n not in [f&#34;{i}&#34; for i in range(1, 11)]:

            err_msg = f&#34;Unsupported number of chars in word {n}.&#34;
            raise ValueError(err_msg)

        # This expression captures all words of specific length which are separated either by
        # commas, periods or dashs. Please note that it might capture numbers aswell.
        expr = fr&#34;\b\w{{{n}}}\b&#34;

    else:

        err_msg = f&#34;Unsupported regex feature {feat_regex_name}.&#34;
        raise ValueError(err_msg)

    return expr</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.preprocessing.features" href="index.html">src.preprocessing.features</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.preprocessing.features.manual_regex.apply_regex_rule" href="#src.preprocessing.features.manual_regex.apply_regex_rule">apply_regex_rule</a></code></li>
<li><code><a title="src.preprocessing.features.manual_regex.create_regex_feat" href="#src.preprocessing.features.manual_regex.create_regex_feat">create_regex_feat</a></code></li>
<li><code><a title="src.preprocessing.features.manual_regex.regex_name_to_expr" href="#src.preprocessing.features.manual_regex.regex_name_to_expr">regex_name_to_expr</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>